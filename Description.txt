Исходная постановка задачи:

Реализовать простую систему просмотра списка товаров.

Товар описывается несколькими полями: id, название, описание, цена, url картинки.
Требуется:
- интерфейс создания/редактирования/удаления товара;
- страница просмотра списка товаров.

Товары можно просмотривать отсортированные по цене или по id.

Поддерживать количество товаров в списке – до 1000000.
Устойчивость к нагрузке – 1000 запросов к списку товаров в минуту.
Время открытия страницы списка товаров < 500 мс.

-------------------

Из-за некоторой расплывчатости формулировок, я позволил себе некоторую свободу в трактовании требований,
в частности:
- Под "списком товаров" понимаем именно базу данных, под "страницей просмотра списка товаров" - именно HTML-страницу.
- Таким образом, на "странице просмотра" не требуется выводить все 1000000 товаров (да и не получится - браузер лопнет).
- Следовательно, исключается вариант с предрассчитанными вариантами списка в разных сортировках.
- Из предыдущего пункта вытекает просмотр списка кусками в заданном порядке сортировки с догрузкой по мере просмотра.
- Про SEO в постановке ничего не сказано, следовательно его не будет.
- Про поиск товара в постановке ничего не сказано, следовательно его тоже не будет.
- Из трех предыдущих пунктов можно сделать вывод, что данные будут запрашиваться строго по порядку индекса, т.е.
Cache hit rate будет достаточно высок для самых горячих данных.
- Поскольку ничего не сказано про полностью случайный доступ ко всем элементам списка товаров, предполагаем, что
типичное поведение будет совпадать с возможностями интерфейса, т.е. полностью случайный доступ к любым страницам
списка практически исключен.
- Устойчивость по нагрузке будем считать, как предельное количество запросов на показ куска списка в единицу времени.
- Время открытия страницы будем считать, как Time to first interactive за вычетом сетевых издержек для страницы,
содержащей первые N товаров (N - количество товаров в куске списка).

--------------------------------

Параметры проведения нагрузки:
- Утилита siege, режим benchmark, файл с урлами (на 300 первых страниц по 100 товаров на каждой).
- Встроенный http-сервер php без fpm и оптимизаций, в 1 поток.
- Локальный mysql, ровно 1,000,000 записей в основной таблице.
- Один поток memcached.
- Железо Intel Core i5-7200U, 16GB RAM.
- ОС Fedora Linux 25 x64, PHP 5.4, Mysql 5.7 community edition.

- При сортировке по id:
Transactions:                  38554 hits
Availability:                 100.00 %
Elapsed time:                  95.47 secs
Data transferred:            1171.40 MB
Response time:                  0.06 secs
Transaction rate:             403.83 trans/sec
Throughput:                    12.27 MB/sec
Concurrency:                   24.95
Successful transactions:       38554
Failed transactions:               0
Longest transaction:            0.29
Shortest transaction:           0.03

- При сортировке по cost:
Transactions:                  33866 hits
Availability:                 100.00 %
Elapsed time:                  81.95 secs
Data transferred:            1023.00 MB
Response time:                  0.06 secs
Transaction rate:             413.25 trans/sec
Throughput:                    12.48 MB/sec
Concurrency:                   24.96
Successful transactions:       33866
Failed transactions:               0
Longest transaction:            0.21
Shortest transaction:           0.01

Потребление памяти php: 20 МБ
Нагрузка на процессор php: 80% на одно ядро
Потребление памяти mysql: 273 МБ
Нагрузка на процессор mysql: 8% на одно ядро
Потребление памяти memcached: 5 МБ
Нагрузка на процессор memcached: 5% на одно ядро

------------

При необходимости дальнейшего увеличения RPS есть несколько зон роста:
- Увеличение числа потоков php, применение fpm
- Увеличение числа процессов memcached, выделение отдельного сервера
- Тюнинг mysql, в частности буферов и лога транзакций innodb
- Шардирование и/или партиционирование БД, организация master/slave репликации для увеличения пропускной
способности на чтение
- Использование особенностей предметной области для построения наиболее эффективных индексов по полям
- Использование внешних индексных систем (sphinx, elastic и пр.)
